First, we thank all the reviewers for their careful reviews and thoughtful
feedback.

We are happy to add the suggested citations.

There was discomfort with informal proofs.  However, ASPLOS has published
such papers, so we suspect that the real discomfort was augmenting the
C++ abstract machine with hardware properties.  20 years of equivocal
progress justifies trying a new approach.  We are not advocating the old
approaches be abandoned.  In fact, we will endeavor to be the first to
offer congratulations should someone succeed.

Various litmus tests were put forward.  Our submission describes how
we rely on a compiler to translate the litmus test to object code, then
relate dependencies in that object code to the corresponding source code.
Section 1.2 ("Prior Work") notes that we are not trying to identify when
OOTA cycles can form, but rather show that OOTA cycles cannot form.

There was also discomfort with use of object code, which varies across
systems.  However, these systems are underpinned by laws of physics,
namely causality, the finite speed of light, and the atomic nature
of matter.  Our definition of OOTA cycles as cycles in (rfe U sdep)
permits us to examine rfe and sdep separately, noting that each rfe link
goes forward in time.  Because an OOTA cycle must return to the starting
time, there must be at least one sdep link that goes backwards in time.
Correct compilers guarantee that sdep links correspond to sequences of
machine instructions, which cannot execute backwards in time, even given
speculative execution.  Thus, the OOTA cycle cannot form.

Please note that correct implementations are not required to break
non-semantic dependencies.  Regardless, a non-semantic dependency cannot
form an OOTA cycle.

Reviewer 72F asks about three litmus tests in Section 5 of the
submission's citation [5], as do a couple of other reviewers:

o	The first example has a dependency only if the implementation
	does not hoist the i++ out of the “if” statement, and this is
	the implementation’s choice, similar to the example in Section
	2.2.5 of the submission.  See Sections 2.2.7 and 2.2.8 for more
	aggressive examples.

o	The second example is handled by examining f() and the
	functions that it invokes, along with the implementation’s
	optimization choices.  This example is yet another motivation
	for the submission’s Section 3, which discusses executions as
	opposed to source-code syntactic dependencies.

o	An instructive elaboration of the third example is discussed in
	Section 2.2.1 of the submission.

Reviewer 72F also asks if we implicitly enforce the load-to-store
ordering advocated by Boehm and Demsky.  We do not.  Instructions do
not necessarily commit in program order.  Furthermore, commit order
might not constrain the order of the corresponding memory references.

Reviewer 72F also asks (in two questions) if freezing of nondeterministic
choices into machine code is realistic.  The answer is "yes", but on the
per-execution basis used in our submission.  For example, specialization
optimizations might cause a given function to be compiled differently
for different combinations of arguments.  But any given execution would
correspond to a particular combination of arguments, and that execution
would be frozen into machine code.  Please note that self-modifying
programs are outside of the standard, and thus out of our scope.

We thank Reviewer 72F for noting that Section 7.4 ("Merging Quasi-Volatile
Loads") poses a challenge.  However, please note that this challenge
is not to our technique, due to our focus on object-code executions.
Community processes will decide whether or not this section's optimization
is legitimate, and these processes' outcomes will be implemented in
compilers, thus being automatically handled by our technique.  The
challenge is instead to OOTA analysis techniques not accounting for these
community processes.  Nevertheless, any abstract-machine mathematical
OOTA solution should have a prominent seat at the community-process table.

Reviewer 72F suggested that rf links must impose restrictions.
Please note our Section 2.1 ("OOTA: rf vs. rfe") where we show that
those restrictions can be extremely loose, hence our use of rfe.
But note also that C++ modification order provides very weak guarantees,
in fact, a later-in-time store might precede an earlier-in-time store
in modification order, even on x86.

Reviwer 72F also questions how the original C++ code can be irrelevant.
The C++ code is relevant, but only at the source-code level and to the
connections between the source-code and object-code levels.  However,
for analysis confined to the object-code level, the origial C++ code
can indeed be irrelevant.

Reviewer 72F asks what we mean by "these models are atemporal".
We mean that typical memory models do not make use of the passage of
physical time.  The provide partial orderings, but as noted earlier,
some orderings can go backwards in time.

Responses to individual reviewer feedback items is in the accompanying
PDF.
